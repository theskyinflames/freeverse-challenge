// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package app_test

import (
	"context"
	"sync"
	"github.com/theskyinflames/cqrs-eda/pkg/cqrs"
	"github.com/theskyinflames/cqrs-eda/pkg/events"
)

// Ensure, that CommandMock does implement cqrs.Command.
// If this is not the case, regenerate this file with moq.
var _ cqrs.Command = &CommandMock{}

// CommandMock is a mock implementation of cqrs.Command.
//
//	func TestSomethingThatUsesCommand(t *testing.T) {
//
//		// make and configure a mocked cqrs.Command
//		mockedCommand := &CommandMock{
//			NameFunc: func() string {
//				panic("mock out the Name method")
//			},
//		}
//
//		// use mockedCommand in code that requires cqrs.Command
//		// and then make assertions.
//
//	}
type CommandMock struct {
	// NameFunc mocks the Name method.
	NameFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Name holds details about calls to the Name method.
		Name []struct {
		}
	}
	lockName sync.RWMutex
}

// Name calls NameFunc.
func (mock *CommandMock) Name() string {
	callInfo := struct {
	}{}
	mock.lockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	mock.lockName.Unlock()
	if mock.NameFunc == nil {
		var (
			sOut string
		)
		return sOut
	}
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//
//	len(mockedCommand.NameCalls())
func (mock *CommandMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockName.RLock()
	calls = mock.calls.Name
	mock.lockName.RUnlock()
	return calls
}

// Ensure, that QueryMock does implement cqrs.Query.
// If this is not the case, regenerate this file with moq.
var _ cqrs.Query = &QueryMock{}

// QueryMock is a mock implementation of cqrs.Query.
//
//	func TestSomethingThatUsesQuery(t *testing.T) {
//
//		// make and configure a mocked cqrs.Query
//		mockedQuery := &QueryMock{
//			NameFunc: func() string {
//				panic("mock out the Name method")
//			},
//		}
//
//		// use mockedQuery in code that requires cqrs.Query
//		// and then make assertions.
//
//	}
type QueryMock struct {
	// NameFunc mocks the Name method.
	NameFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Name holds details about calls to the Name method.
		Name []struct {
		}
	}
	lockName sync.RWMutex
}

// Name calls NameFunc.
func (mock *QueryMock) Name() string {
	callInfo := struct {
	}{}
	mock.lockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	mock.lockName.Unlock()
	if mock.NameFunc == nil {
		var (
			sOut string
		)
		return sOut
	}
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//
//	len(mockedQuery.NameCalls())
func (mock *QueryMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockName.RLock()
	calls = mock.calls.Name
	mock.lockName.RUnlock()
	return calls
}

// Ensure, that CommandHandlerMock does implement cqrs.CommandHandler.
// If this is not the case, regenerate this file with moq.
var _ cqrs.CommandHandler = &CommandHandlerMock{}

// CommandHandlerMock is a mock implementation of cqrs.CommandHandler.
//
//	func TestSomethingThatUsesCommandHandler(t *testing.T) {
//
//		// make and configure a mocked cqrs.CommandHandler
//		mockedCommandHandler := &CommandHandlerMock{
//			HandleFunc: func(contextMoqParam context.Context, command cqrs.Command) ([]cqrs.Event, error) {
//				panic("mock out the Handle method")
//			},
//		}
//
//		// use mockedCommandHandler in code that requires cqrs.CommandHandler
//		// and then make assertions.
//
//	}
type CommandHandlerMock struct {
	// HandleFunc mocks the Handle method.
	HandleFunc func(contextMoqParam context.Context, command cqrs.Command) ([]events.Event, error)

	// calls tracks calls to the methods.
	calls struct {
		// Handle holds details about calls to the Handle method.
		Handle []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Command is the command argument value.
			Command cqrs.Command
		}
	}
	lockHandle sync.RWMutex
}

// Handle calls HandleFunc.
func (mock *CommandHandlerMock) Handle(contextMoqParam context.Context, command cqrs.Command) ([]events.Event, error) {
	callInfo := struct {
		ContextMoqParam context.Context
		Command         cqrs.Command
	}{
		ContextMoqParam: contextMoqParam,
		Command:         command,
	}
	mock.lockHandle.Lock()
	mock.calls.Handle = append(mock.calls.Handle, callInfo)
	mock.lockHandle.Unlock()
	if mock.HandleFunc == nil {
		var (
			eventsOut []events.Event
			errOut    error
		)
		return eventsOut, errOut
	}
	return mock.HandleFunc(contextMoqParam, command)
}

// HandleCalls gets all the calls that were made to Handle.
// Check the length with:
//
//	len(mockedCommandHandler.HandleCalls())
func (mock *CommandHandlerMock) HandleCalls() []struct {
	ContextMoqParam context.Context
	Command         cqrs.Command
} {
	var calls []struct {
		ContextMoqParam context.Context
		Command         cqrs.Command
	}
	mock.lockHandle.RLock()
	calls = mock.calls.Handle
	mock.lockHandle.RUnlock()
	return calls
}

// Ensure, that QueryHandlerMock does implement cqrs.QueryHandler.
// If this is not the case, regenerate this file with moq.
var _ cqrs.QueryHandler = &QueryHandlerMock{}

// QueryHandlerMock is a mock implementation of cqrs.QueryHandler.
//
//	func TestSomethingThatUsesQueryHandler(t *testing.T) {
//
//		// make and configure a mocked cqrs.QueryHandler
//		mockedQueryHandler := &QueryHandlerMock{
//			HandleFunc: func(contextMoqParam context.Context, query cqrs.Query) (cqrs.QueryResult, error) {
//				panic("mock out the Handle method")
//			},
//		}
//
//		// use mockedQueryHandler in code that requires cqrs.QueryHandler
//		// and then make assertions.
//
//	}
type QueryHandlerMock struct {
	// HandleFunc mocks the Handle method.
	HandleFunc func(contextMoqParam context.Context, query cqrs.Query) (cqrs.QueryResult, error)

	// calls tracks calls to the methods.
	calls struct {
		// Handle holds details about calls to the Handle method.
		Handle []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Query is the query argument value.
			Query cqrs.Query
		}
	}
	lockHandle sync.RWMutex
}

// Handle calls HandleFunc.
func (mock *QueryHandlerMock) Handle(contextMoqParam context.Context, query cqrs.Query) (cqrs.QueryResult, error) {
	callInfo := struct {
		ContextMoqParam context.Context
		Query           cqrs.Query
	}{
		ContextMoqParam: contextMoqParam,
		Query:           query,
	}
	mock.lockHandle.Lock()
	mock.calls.Handle = append(mock.calls.Handle, callInfo)
	mock.lockHandle.Unlock()
	if mock.HandleFunc == nil {
		var (
			queryResultOut cqrs.QueryResult
			errOut         error
		)
		return queryResultOut, errOut
	}
	return mock.HandleFunc(contextMoqParam, query)
}

// HandleCalls gets all the calls that were made to Handle.
// Check the length with:
//
//	len(mockedQueryHandler.HandleCalls())
func (mock *QueryHandlerMock) HandleCalls() []struct {
	ContextMoqParam context.Context
	Query           cqrs.Query
} {
	var calls []struct {
		ContextMoqParam context.Context
		Query           cqrs.Query
	}
	mock.lockHandle.RLock()
	calls = mock.calls.Handle
	mock.lockHandle.RUnlock()
	return calls
}