// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package app_test

import (
	"context"
	"github.com/google/uuid"
	"sync"
	"theskyinflames/graphql-challenge/internal/app"
	"theskyinflames/graphql-challenge/internal/domain"
)

// Ensure, that ProductsRepositoryMock does implement app.ProductsRepository.
// If this is not the case, regenerate this file with moq.
var _ app.ProductsRepository = &ProductsRepositoryMock{}

// ProductsRepositoryMock is a mock implementation of app.ProductsRepository.
//
//	func TestSomethingThatUsesProductsRepository(t *testing.T) {
//
//		// make and configure a mocked app.ProductsRepository
//		mockedProductsRepository := &ProductsRepositoryMock{
//			FindAllFunc: func(ctx context.Context) ([]domain.Product, error) {
//				panic("mock out the FindAll method")
//			},
//			FindByIDFunc: func(ctx context.Context, ID uuid.UUID) (domain.Product, error) {
//				panic("mock out the FindByID method")
//			},
//			UpdateAvailableFunc: func(ctx context.Context, p domain.Product) error {
//				panic("mock out the UpdateAvailable method")
//			},
//		}
//
//		// use mockedProductsRepository in code that requires app.ProductsRepository
//		// and then make assertions.
//
//	}
type ProductsRepositoryMock struct {
	// FindAllFunc mocks the FindAll method.
	FindAllFunc func(ctx context.Context) ([]domain.Product, error)

	// FindByIDFunc mocks the FindByID method.
	FindByIDFunc func(ctx context.Context, ID uuid.UUID) (domain.Product, error)

	// UpdateAvailableFunc mocks the UpdateAvailable method.
	UpdateAvailableFunc func(ctx context.Context, p domain.Product) error

	// calls tracks calls to the methods.
	calls struct {
		// FindAll holds details about calls to the FindAll method.
		FindAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FindByID holds details about calls to the FindByID method.
		FindByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID uuid.UUID
		}
		// UpdateAvailable holds details about calls to the UpdateAvailable method.
		UpdateAvailable []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// P is the p argument value.
			P domain.Product
		}
	}
	lockFindAll         sync.RWMutex
	lockFindByID        sync.RWMutex
	lockUpdateAvailable sync.RWMutex
}

// FindAll calls FindAllFunc.
func (mock *ProductsRepositoryMock) FindAll(ctx context.Context) ([]domain.Product, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFindAll.Lock()
	mock.calls.FindAll = append(mock.calls.FindAll, callInfo)
	mock.lockFindAll.Unlock()
	if mock.FindAllFunc == nil {
		var (
			productsOut []domain.Product
			errOut      error
		)
		return productsOut, errOut
	}
	return mock.FindAllFunc(ctx)
}

// FindAllCalls gets all the calls that were made to FindAll.
// Check the length with:
//
//	len(mockedProductsRepository.FindAllCalls())
func (mock *ProductsRepositoryMock) FindAllCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFindAll.RLock()
	calls = mock.calls.FindAll
	mock.lockFindAll.RUnlock()
	return calls
}

// FindByID calls FindByIDFunc.
func (mock *ProductsRepositoryMock) FindByID(ctx context.Context, ID uuid.UUID) (domain.Product, error) {
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockFindByID.Lock()
	mock.calls.FindByID = append(mock.calls.FindByID, callInfo)
	mock.lockFindByID.Unlock()
	if mock.FindByIDFunc == nil {
		var (
			productOut domain.Product
			errOut     error
		)
		return productOut, errOut
	}
	return mock.FindByIDFunc(ctx, ID)
}

// FindByIDCalls gets all the calls that were made to FindByID.
// Check the length with:
//
//	len(mockedProductsRepository.FindByIDCalls())
func (mock *ProductsRepositoryMock) FindByIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockFindByID.RLock()
	calls = mock.calls.FindByID
	mock.lockFindByID.RUnlock()
	return calls
}

// UpdateAvailable calls UpdateAvailableFunc.
func (mock *ProductsRepositoryMock) UpdateAvailable(ctx context.Context, p domain.Product) error {
	callInfo := struct {
		Ctx context.Context
		P   domain.Product
	}{
		Ctx: ctx,
		P:   p,
	}
	mock.lockUpdateAvailable.Lock()
	mock.calls.UpdateAvailable = append(mock.calls.UpdateAvailable, callInfo)
	mock.lockUpdateAvailable.Unlock()
	if mock.UpdateAvailableFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateAvailableFunc(ctx, p)
}

// UpdateAvailableCalls gets all the calls that were made to UpdateAvailable.
// Check the length with:
//
//	len(mockedProductsRepository.UpdateAvailableCalls())
func (mock *ProductsRepositoryMock) UpdateAvailableCalls() []struct {
	Ctx context.Context
	P   domain.Product
} {
	var calls []struct {
		Ctx context.Context
		P   domain.Product
	}
	mock.lockUpdateAvailable.RLock()
	calls = mock.calls.UpdateAvailable
	mock.lockUpdateAvailable.RUnlock()
	return calls
}
